# **DFS (Depth-First Search) - 깊이 우선 탐색**

### 1. 개념 설명 (What is it?)

- DFS는 그래프나 트리의 **모든 정점을 깊게** 탐색한 후, **더 이상 갈 곳이 없으면** 다시 돌아오는 방식의 탐색 알고리즘입니다.
- 스택 자료구조를 활용하거나 재귀 함수로 구현할 수 있습니다.

### 2. 사용하는 이유 (Why use it?)

- **경로 탐색**이 필요한 경우 유용 (예: 미로 찾기, 모든 조합 탐색)
- **사이클 탐지**, **연결 요소 탐색** 등에서 직관적이고 구현이 간단
- 재귀적으로 구조를 단순하게 표현할 수 있음

### 3. 적용 조건 (When to use it?)

- 그래프나 트리 구조일 때
- **모든 노드를 한 번씩** 방문하면서 특정 조건을 찾고 싶을 때
- **백트래킹**과 함께 쓰기 좋음

> 제한: 깊은 재귀가 필요한 경우 스택 오버플로우 주의 (보통 10⁴ 이상 깊이는 비재귀 방식 권장)
> 

### 4. 알고리즘 구조 (How it works)

1. 시작 노드를 방문 (방문 표시)
2. 연결된 노드 중 방문하지 않은 노드로 이동
3. 더 이상 방문할 곳이 없으면 이전 노드로 되돌아감 (백트래킹)
4. 모든 노드를 탐색할 때까지 반복

### 5. 시간 복잡도 & 공간 복잡도

| 복잡도 종류 | 값 |
| --- | --- |
| 시간 복잡도 | O(V + E) → 정점 수 V, 간선 수 E |
| 공간 복잡도 | O(V) → 방문 배열 + 호출 스택 |

### 6. 예제 코드 (Code Example)

```swift
func dfs(_ graph: [[Int]], _ visited: inout [Bool], _ node: Int) {
    visited[node] = true
    print("방문:", node)

    for next in graph[node] {
        if !visited[next] {
            dfs(graph, &visited, next)
        }
    }
}

let graph = [
    [],         // 0번 노드 사용 안 함
    [2, 3],     // 1번 노드와 연결된 노드들
    [1, 4],
    [1, 5],
    [2],
    [3]
]

var visited = Array(repeating: false, count: 6)
dfs(graph, &visited, 1)

// 출력 예시: 1 → 2 → 4 → 3 → 5
```

### **7. 실전 문제 예시**

- [백준 11724번 - 연결 요소의 개수](https://www.acmicpc.net/problem/11724)
- [백준 2606번 - 바이러스](https://www.acmicpc.net/problem/2606)
- [LeetCode 200 - Number of Islands](https://leetcode.com/problems/number-of-islands/)

### **8. 주의할 점 / 실수하기 쉬운 부분**

- **방문 처리 시점**을 늦게 하면 중복 탐색 발생 가능
- **그래프 입력 방식** 주의 (인접 리스트 vs 인접 행렬)
- 재귀 깊이 초과 → 스택 오버플로우 가능 → 반복문 기반 구현 필요

### **9. 관련 알고리즘**

- **BFS (너비 우선 탐색)**: 가까운 노드부터 탐색 (큐 기반)
- **백트래킹**: DFS의 한 형태, 조건을 만족하지 않으면 탐색 중단
- **Topological Sort**: DFS 후 역방향으로 정렬해 위상정렬 구현
