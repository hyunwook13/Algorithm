# ðŸ§  Dynamic Programming

### 1. ê°œë… ì„¤ëª… (What is it?)

- í° ë¬¸ì œë¥¼ ìž‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆ„ê³ , ë¶€ë¶„ ë¬¸ì œì˜ ê²°ê³¼ë¥¼ ì €ìž¥í•´ ì¤‘ë³µ ê³„ì‚° ì—†ì´ ì „ì²´ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ìµœì í™” ì•Œê³ ë¦¬ì¦˜ ê¸°ë²•.

### 2. ì‚¬ìš©í•˜ëŠ” ì´ìœ  (Why use it?)

- ì¤‘ë³µ ê³„ì‚°ì„ ì¤„ì—¬ ì‹œê°„ ë³µìž¡ë„ë¥¼ íšê¸°ì ìœ¼ë¡œ ê°œì„ í•  ìˆ˜ ìžˆìŒ
- ì™„ì „ íƒìƒ‰ë³´ë‹¤ í›¨ì”¬ íš¨ìœ¨ì ì´ë©°, íƒìš•ë²•ìœ¼ë¡œëŠ” í•´ê²° ë¶ˆê°€ëŠ¥í•œ ìµœì í™” ë¬¸ì œì—ë„ ì‚¬ìš© ê°€ëŠ¥

### 3. ì ìš© ì¡°ê±´ (When to use it?)

- Optimal Substructure (ìµœì  ë¶€ë¶„ êµ¬ì¡°)
    - í° ë¬¸ì œì˜ ìµœì í•´ê°€ ìž‘ì€ ë¬¸ì œì˜ ìµœì í•´ë¡œë¶€í„° êµ¬ì„±ë  ìˆ˜ ìžˆì–´ì•¼ í•¨
- Overlapping Subproblems (ì¤‘ë³µ ë¶€ë¶„ ë¬¸ì œ
    - ë™ì¼í•œ í•˜ìœ„ ë¬¸ì œê°€ ì—¬ëŸ¬ ë²ˆ ë°˜ë³µí•´ì„œ ë“±ìž¥

### 4. ì•Œê³ ë¦¬ì¦˜ êµ¬ì¡° (How it works)

1. í•˜í–¥ì‹ (Top-Down) â€“ ìž¬ê·€ + ë©”ëª¨ì´ì œì´ì…˜
- f(n) = f(n-1) + f(n-2)ì²˜ëŸ¼ ìž¬ê·€ì ìœ¼ë¡œ ë¬¸ì œë¥¼ ë‚˜ëˆ”
    - ê³„ì‚°ëœ ê²°ê³¼ëŠ” memo[n]ì— ì €ìž¥í•´ ì¤‘ë³µ ê³„ì‚° ë°©ì§€
1. ìƒí–¥ì‹ (Bottom-Up) â€“ ë°˜ë³µë¬¸ + DP í…Œì´ë¸”
- ìž‘ì€ ë¬¸ì œë¶€í„° ì°¨ë¡€ë¡œ í•´ê²°í•˜ë©° **í…Œì´ë¸”(dp ë°°ì—´)**ì„ ì±„ì›€
    - ì´ˆê¸° ì¡°ê±´ë¶€í„° ì‹œìž‘í•´, ë°˜ë³µë¬¸ìœ¼ë¡œ ì ì§„ì ìœ¼ë¡œ í™•ìž¥

### 5. ì‹œê°„ ë³µìž¡ë„ & ê³µê°„ ë³µìž¡ë„

- ì‹œê°„ ë³µìž¡ë„: ë¬¸ì œë§ˆë‹¤ ë‹¤ë¥´ì§€ë§Œ ì¼ë°˜ì ìœ¼ë¡œ O(n) ë˜ëŠ” O(n * m)
- ê³µê°„ ë³µìž¡ë„: O(n) ì´ìƒ (í…Œì´ë¸” ë˜ëŠ” ìºì‹œì˜ í¬ê¸°ì— ë”°ë¼ ë‹¤ë¦„)
- ìƒí–¥ì‹ì—ì„œëŠ” **ê³µê°„ ìµœì í™” (2ê°œì˜ ë³€ìˆ˜ë¡œ ì¶•ì†Œ)**ë„ ê°€ëŠ¥

### 6. ì˜ˆì œ ì½”ë“œ (Code Example)

- í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ â€“ Top-Down with Memoization

```swift
var memo = [Int](repeating: -1, count: 100)

func fib(_ n: Int) -> Int {
    if n <= 1 { return n }
    if memo[n] != -1 {
        return memo[n]
    }
    memo[n] = fib(n - 1) + fib(n - 2)
    return memo[n]
}
```

- í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ â€“ Bottom-Up

```swift
func fib(_ n: Int) -> Int {
    if n <= 1 { return n }
    var dp = [Int](repeating: 0, count: n + 1)
    dp[1] = 1

    for i in 2...n {
        dp[i] = dp[i - 1] + dp[i - 2]
    }

    return dp[n]
}
```

### 7. ì‹¤ì „ ë¬¸ì œ ì˜ˆì‹œ (Practice Problems)

- ë°±ì¤€ 1463 â€“ 1ë¡œ ë§Œë“¤ê¸°
- LeetCode 198 â€“ House Robber
- í”„ë¡œê·¸ëž˜ë¨¸ìŠ¤ â€“ ì •ìˆ˜ ì‚¼ê°í˜•

### 8. ì£¼ì˜í•  ì  / ì‹¤ìˆ˜í•˜ê¸° ì‰¬ìš´ ë¶€ë¶„

- ê²½ê³„ ì¡°ê±´(ì´ˆê¸°ê°’) ì„¤ì •ì´ í‹€ë¦¬ë©´ ì „ì²´ DPê°€ ë¬´ë„ˆì§ˆ ìˆ˜ ìžˆìŒ
- ìž¬ê·€ë¡œ í•  ê²½ìš° ìµœëŒ€ í˜¸ì¶œ ê¹Šì´ ì´ˆê³¼ ì£¼ì˜
- ë°˜ë³µë¬¸ ë²”ìœ„ ì„¤ì •ì„ ìž˜ëª»í•˜ë©´ off-by-one ì˜¤ë¥˜ ë°œìƒ

### 9. ê´€ë ¨ ì•Œê³ ë¦¬ì¦˜ / íŒ¨í„´

- DFS + Memoization (íƒ‘ë‹¤ìš´ DPì˜ ë˜ ë‹¤ë¥¸ í˜•íƒœ)
- Knapsack Problem
- Divide and Conquer DP
- Bitmask DP, LIS(Longest Increasing Subsequence)
